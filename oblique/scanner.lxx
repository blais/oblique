/* -*- mode: c++ -*- */
// Scanner definition for Oblique language (for RE-Flex).
// Note: All inserted code blocks are in the body.

%top{
#include "oblique/parser.h"    /* Generated by bison. */
#include "oblique/location.h"  /* Generated by bison %locations. */

#include <utility>
#include <cassert>

#include "reflex/matcher.h"
#include "absl/strings/string_view.h"

namespace oblique {

// Using declarations for symbols in the scanner implementation only.
using absl::string_view;
using oblique::parser::Parser;
using std::endl;
using std::string;

inline strview view(const reflex::Matcher& m) {
  return strview(m.begin(), m.size());
}

}  // namespace oblique
}

//- Definitions ---------------------------------------------------------------
%option bison-complete
%option bison-cc-namespace=oblique::parser
%option bison-cc-parser=Parser
%option bison-locations

// Throw an exception in the scanner's default rule.
%option exception="oblique::parser::Parser::syntax_error(location(), \"Unknown token.\")"

%option namespace=oblique::scanner
%option lexer=Scanner

%option tabs=8
%option fast
%option unicode
%option indent
%option nodefault

// Regexp patterns.
type	[a-z]+
ident	[a-zA-Z0-9_-]+
punct	[();:.]
comment	(#+|;;+)
// TODO(blais): Remove or refine alternative ";;" comment syntax.

//- Rules ---------------------------------------------------------------------
%%

// Indent.
^\h+\i {
  return Parser::make_INDENT(location());
}

// Eat empty lines without affecting indent stops.
(?^^\h*\n)

// Comment.
^\h*{comment}[^\n]* {
  absl::string_view s = view(matcher());
  int index = 0;
  for (const char c : s) {
    if (c != ' ' && c != '\t')
      break;
    index++;
  }
  if (index > 0) {
    s = s.substr(index, string::npos);
  }
  // TODO(blais): Use string_view
  return Parser::make_COMMENT(string(s), location());
}

// Commands associated with a type.
\/(type|lazytype)\/{ident} {
  auto s = view(matcher());
  int pos = s.find('/', 1);
  assert(pos != string::npos);
  auto ident = s.substr(pos + 1, string::npos);
  if (s.substr(0, pos) == "/type") {
    return Parser::make_TYPE(ident, location());
  } else {
    return Parser::make_LAZYTYPE(ident, location());
  }
}

\/ignore\/{ident} {
  auto s = view(matcher());
  int pos = s.find('/', 1);
  assert(pos != string::npos);
  auto ident = s.substr(pos + 1, string::npos);
  return Parser::make_IGNORE(ident, location());
}

\/macro     { return Parser::make_MACRO(location()); }
\/import    { return Parser::make_IMPORT(location()); }

// Object reference.
//
// Note: We use trailing context to allow following punctuation to match the
// next character and take precedence over the general word pattern (we're using
// the POSIX longest matching pattern rule; see reflex documentation).
{type}\/{ident}|{type}\/{ident}/{punct} {
  // Split the type and ident here in the scanner.
  auto s = view(matcher());
  int pos = s.find('/');
  assert(pos != string::npos);
  auto ref = new proto::Ref;
  ref->set_type(s.data(), pos);
  pos++;
  ref->set_ident(s.data() + pos, s.size() - pos);
  return Parser::make_REF(ref, location());  // Ownership transfer to token.
}

// Auto object reference.
{type}\/ {
  auto v = view(matcher());
  v.remove_suffix(1);
  return Parser::make_AUTOREF(v, location());
}

// Any word.
[^ \t\r\n]+ {
  return Parser::make_WORD(view(matcher()), location());
}

// An end of line.
\r?\n {
  return Parser::make_EOL(location());
}

// Ignore whitespace.
[ \t]+

// TODO(blais): Turn this into the default rule and fail instead.
. {
  out() << "TODO(blais): remove - XXX{" << text() << "{XXX" << endl;
} // Unknown
%%

//-----------------------------------------------------------------------------
// Code: Scanner Body
